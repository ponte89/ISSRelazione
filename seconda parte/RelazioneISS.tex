\documentclass{llncs}
\let\ifpddf\relax
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% package sillabazione italiana e uso lettere accentate
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{url}
\usepackage{xspace}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{manifest}

\makeatother


%%%%%%%
 \newif\ifpdf
 \ifx\pdfoutput\undefined
 \pdffalse % we are not running PDFLaTeX
 \else
 \pdfoutput=1 % we are running PDFLaTeX
 \pdftrue
 \fi
%%%%%%%
 \ifpdf
 \usepackage[pdftex]{graphicx}
 \else
 \usepackage{graphicx}
 \fi
%%%%%%%%%%%%%%%
 \ifpdf
 \DeclareGraphicsExtensions{.pdf, .jpg, .tif}
 \else
 \DeclareGraphicsExtensions{.eps, .jpg}
 \fi
%%%%%%%%%%%%%%%

\newcommand{\java}{\textsf{Java}}
\newcommand{\contact}{\emph{Contact}}
\newcommand{\corecl}{\texttt{corecl}}
\newcommand{\medcl}{\texttt{medcl}}
\newcommand{\msgcl}{\texttt{msgcl}}
\newcommand{\android}{\texttt{Android}}
\newcommand{\dsl}{\texttt{DSL}}
\newcommand{\jazz}{\texttt{Jazz}}
\newcommand{\rtc}{\texttt{RTC}}
\newcommand{\ide}{\texttt{Contact-ide}}
\newcommand{\xtext}{\texttt{XText}}
\newcommand{\xpand}{\texttt{Xpand}}
\newcommand{\xtend}{\texttt{Xtend}}
\newcommand{\pojo}{\texttt{POJO}}
\newcommand{\junit}{\texttt{JUnit}}

\newcommand{\action}[1]{\texttt{#1}\xspace}
\newcommand{\code}[1]{{\small{\texttt{#1}}}\xspace}
\newcommand{\codescript}[1]{{\scriptsize{\texttt{#1}}}\xspace}

% Cross-referencing
\newcommand{\labelsec}[1]{\label{sec:#1}}
\newcommand{\xs}[1]{\sectionname~\ref{sec:#1}}
\newcommand{\xsp}[1]{\sectionname~\ref{sec:#1} \onpagename~\pageref{sec:#1}}
\newcommand{\labelssec}[1]{\label{ssec:#1}}
\newcommand{\xss}[1]{\subsectionname~\ref{ssec:#1}}
\newcommand{\xssp}[1]{\subsectionname~\ref{ssec:#1} \onpagename~\pageref{ssec:#1}}
\newcommand{\labelsssec}[1]{\label{sssec:#1}}
\newcommand{\xsss}[1]{\subsectionname~\ref{sssec:#1}}
\newcommand{\xsssp}[1]{\subsectionname~\ref{sssec:#1} \onpagename~\pageref{sssec:#1}}
\newcommand{\labelfig}[1]{\label{fig:#1}}
\newcommand{\xf}[1]{\figurename~\ref{fig:#1}}
\newcommand{\xfp}[1]{\figurename~\ref{fig:#1} \onpagename~\pageref{fig:#1}}
\newcommand{\labeltab}[1]{\label{tab:#1}}
\newcommand{\xt}[1]{\tablename~\ref{tab:#1}}
\newcommand{\xtp}[1]{\tablename~\ref{tab:#1} \onpagename~\pageref{tab:#1}}
% Category Names
\newcommand{\sectionname}{Section}
\newcommand{\subsectionname}{Subsection}
\newcommand{\sectionsname}{Sections}
\newcommand{\subsectionsname}{Subsections}
\newcommand{\secname}{\sectionname}
\newcommand{\ssecname}{\subsectionname}
\newcommand{\secsname}{\sectionsname}
\newcommand{\ssecsname}{\subsectionsname}
\newcommand{\onpagename}{on page}

\newcommand{\xauthA}{NameA StudentA }
\newcommand{\xauthB}{NameB StudentB}
\newcommand{\xauthC}{NameC StudentC}
\newcommand{\xfaculty}{II Faculty of Engineering}
\newcommand{\xunibo}{Alma Mater Studiorum -- University of Bologna}
\newcommand{\xaddrBO}{viale Risorgimento 2}
\newcommand{\xaddrCE}{via Venezia 52}
\newcommand{\xcityBO}{40136 Bologna, Italy}
\newcommand{\xcityCE}{47023 Cesena, Italy}

%
% Comments
%
%%% \newcommand{\todo}[1]{\bf{TODO:}\emph{#1}}


\begin{document}

\title{Ingegneria dei Sistemi Software\\ A differential drive Robot\\ \footnotesize Seconda Parte}

% \author{\xauthA \and \xauthB}
\author{Beatrice Mezzapesa, Alessia Papini, Lorenzo Pontellini}

\institute{%
%%%  \xunibo\\\xaddrCE, \xcityCE\\\email{\{nameA.studentA, nameB.studentB\}@studio.unibo.it}
  \xunibo\\\xaddrCE, \xcityCE\\\email\{beatrice.mezzapesa, alessia.papini, lorenzo.pontellini\}@studio.unibo.it
}

\maketitle

%% \begin{abstract}
%% \footnotesize
%%This a Latex template to be used for the reports of Software Engineering.
%%\keywords{Software engineering, managed software development, reports, ....}
%%\end{abstract}

%%% \sloppy

%===========================================================================
\section{Introduction}
\labelsec{intro}
Attraverso l'uso del seguente report, si vogliono esprimere i fatti e le interazioni avvenute nella gestione e sviluppo di un sistema software per il controllo di un robot in ambiente protetto. Un ulteriore scopo è quello di fornire uno storico per la gestione del processo produttivo del sistema software esprimendo fatti rilevanti attraverso l'uso di modelli formali interpretabili anche da personale non tecnico. Ci si avvale inoltre del supporto di un meta modello custom che permette di realizzare prototipi funzionanti abbattendo i tempi di testing del sistema.
Il compimento e la gestione del seguente progetto si portano dunque al quarto livello dello standard CMM (Capability Maturity Model) cioè processo produttivo managed. Questo sta a significare come l'organizzazione sia capace di costruire prodotti software, impostando una fase di predizione dei costi e del piano di lavoro, basandosi su una classificazione dei compiti e dei componenti e su metriche di misura dei loro costi e tempi di sviluppo.

%===========================================================================

%===========================================================================
\section{Vision}
\labelsec{Vision}
Parlando di robot, questi sistemi eterogenei software e hardware sono diventati sempre più pervasivi nell'ambito umano, sia da un punto di vista di utilità, si pensi solamente a quelli adibiti alla pulizia in maniera autonoma, ma anche dal punto di vista di semplici strumenti costruiti allo scopo di divertirsi e imparare che hanno portato alla generazione di un vero e proprio businnes.
Quello sul quale ci si vuole concentrare è l'ambito delle Internet Of Things (IoT) che è un settore tutt'ora in espansione e per il quale, per fortuna, ancora non si conoscono limiti di utilizzo.
Il corso proposto, e in generale l'Università si propone di fornire una serie di basi che spaziano dal punto di vista progettuale, implementando così anche le tecniche di Learn By Doing, a quella realizzativo di sistemi che possano essere a loro volta software factory per sistemi robotici immersi nelle differenti aree dell'IoT. 
Il campo di applicazione scelto, appunto quello dei robot, risulta possedere delle caratteristiche di forte dinamicità dettate dagli avanzamenti tecnologici fatti negli ultimi anni che richiedono un software sempre aggiornato all'ultima versione, in grado di funzionare correttamente in ogni condizione. Quest'ultimo si traduce nella stesura di software, sempre con meno tempo a disposizione ma, che possa essere facilmente testato e validato. Per questi motivi a supporto dell'attività didattica di sviluppo software si vogliono sperimentare delle metodologie di produzione del software  gestite da software factory, così da avere sempre una base di conoscenza consistente e che permettano la modifica e il riutilizzo di codice prodotto precedentemente, così da poterlo fare in tempi brevi per poi sottoporlo a verifiche da parte del personale.
Per questi motivi il team prevede l'utilizzo di \textbf{Domani Specific Language} per la produzione di codice abbattendo i tempi e i costi di produzione e gestione.


%===========================================================================

%===========================================================================
\section{Goals}
\labelsec{Goals}
L'obiettivo non è solamente quello di realizzare quando descritto nella sezione delle richieste, ma prevede anche uno studio delle metodologie di realizzazione dei sistemi di questo tipo seguendo le linee guida esposte a lezione.
Relativamente al problema in esame si vuole riconoscere e valutare la presenza di un abstraction gap già al termine della fase di analisi del problema, riuscendo inoltre a discriminare tra gli aspetti relativi al dominio in questione (\textbf{domain specific}) e quelli relativi alla realizzazione dell'applicazione (\textbf{application specific}), come l'ipotesi tecnologica influisca sul processo di produzione del software.	
Altro punto fondamentale sul quale si vuole porre attenzione è l'estensione del Domain Specific Language aziendale utilizzato così da poter costituire un patrimonio informativo comune sempre aggiornato con nuove soluzione tecnologiche adatte a nuove problematiche evidenziate.
La costituzione di un prototipo funzionante risulta essere un ulteriore goal da soddisfare, questo, come già detto, risulta essere realizzato con l'utilizzo della software factory, la quale, permette una rapida e robusta prototipazione al termine della fase di analisi consentendone la presentazione al committente per la pianificazione delle successive attività di progetto e sviluppo attraverso specifico workplan.	
Le linee guida alle quali si decide di ispirarsi sono quelle dettate dalla metodologia di sviluppo chiamata \textbf{SCRUM}, dalla quale cercheremo di sfruttare l'approccio di generazione e gestione del software.
%===========================================================================

%===========================================================================
\section{Requirements}
\labelsec{Requirements}

\subsection{Fase 2}
Progettare un sistema software che:
\begin{itemize}
	\item Permetta di specificare un'azione temporizzata: ovvero esplicitando direttamente la durata dell'azione all'interno comando impartito al Differential Drive Robot (DDR).
	\item Permetta di definire azioni interrompibili: ovvero il robot è in grado di interrrompere l'esecuzione di un comando in seguito alla ricezione un segnale di halt proveniente da una console remota.
	\item Permette di controllare un DDR attraverso una console remota: ovvero inviare comandi al robot il quale deve essere in grado di interpretarli ed agire di conseguenza.	
\end{itemize}

%===========================================================================

 
%===========================================================================
\section{Requirement analysis}
\labelsec{ReqAnalysis}

Avendo definto i requisiti nella prima relazione\footnote{Ingegneria dei Sistemi Software A differential drive Robot Prima Parte}, si specificano in maniera più approfondita delle aree che non erano state identificate:
\begin{itemize}
	\item Definizione di una sequenza di azioni;
	\item Definizione di azione temporizzata;
	\item Definizione di azione interrompibile;
	\item Definizione di console remota.
\end{itemize}

\subsection{Piano di azioni}
Un piano a questo livello può essere identificato da un nome e composto da una serie di azioni che dovranno essere performate dal robot.

\subsection{Azione temporizzata}
 Comando impartito al robot che prevede nella sua definizione oltre al tipo di azione anche la sua effettiva durata.

\subsection{Azione interrompibile}
Azione che prevede una esecuzione con tipologia asincrona ovvero all'interno del proprio piano, una azione asincrona prevede la possibilità di essere interrotta alla ricezione di una nuova azione o di un comando di halt proveniente dalla console.

\subsection{Console remota}
La console remota riveste il ruolo di emittente di determinati segnali in grado di essere captati e interpretati dal robot specifico.

%===========================================================================
\subsection{Use cases}
\labelssec{UseCases}

\begin{tabular}{ | c | }
	\hline
	Fase 2 \\
	\hline
	\hline
	\includegraphics[scale = 0.5]{img/casoUso.jpg}\\
	\hline
\end{tabular}

\subsection{Scenarios}
\labelssec{Scenarios}

\begin{tabular}{|p{4.0cm}|p{8.0cm}|}
	\hline
	ID: & Movimento autonomo temporizzato.\\
	\hline
	Descrizione: & Il robot esegue un piano che comprende azioni temporizzate. \\ 
	\hline
	Attore: & Robot \\
	\hline
	Precondizione: & Il robot deve essere acceso. \\
	\hline
	Scenario Principale: & Il robot sta eseguendo i comandi previsti dal piano specificato.\\
	\hline
	Scenario Secondario: & Assenti.\\
	\hline
	Postcondizione: & Assenti. \\
	\hline
\end{tabular}
\\
\\
\\
\begin{tabular}{|p{4.0cm}|p{8.0cm}|}
	\hline
	ID: & Ricezione comando "halt".\\
	\hline
	Descrizione: & Il sistema percepisce un comando "halt" inviato da console remota e reagisce interrompendo il piano in esecuzione. \\ 
	\hline
	Attore: & Utente \\
	\hline
	Precondizione: & Il robot deve essere acceso e si sta muovendo in maniera autonoma.\\
	\hline
	Scenario Principale: & Il robot termina il piano in esecuzione.\\
	\hline
	Scenario Secondario: & Assenti.\\
	\hline
	Postcondizione: & Il robot è fermo. \\
	\hline
\end{tabular}
\\
\\
\\
\begin{tabular}{|p{4.0cm}|p{8.0cm}|}
	\hline
	ID: & Ricezione comandi di movimento.\\
	\hline
	Descrizione: & Il robot percepisce un comando di movimento inviato da
	console remota ed esegue l?azione corrispondente. \\ 
	\hline
	Attore: & Utente \\
	\hline
	Precondizione: & Il robot deve essere acceso.\\
	\hline
	Scenario Principale: & Il robot deve eseguire i comandi percepiti.\\
	\hline
	Scenario Secondario: & Assenti.\\
	\hline
	Postcondizione: & Il robot rimane in attesa di un comando. \\
	\hline
\end{tabular}


\subsection{(Domain)model}
Si veda la relazione precedente\footnote{Ingegneria dei Sistemi Software A differential drive Robot Prima Parte}.

\subsection{Test plan}
Si veda la relazione precedente\footnote{Ingegneria dei Sistemi Software A differential drive Robot Prima Parte}.

%===========================================================================
\section{Problem analysis}
\labelsec{ProblemAnalysis}
Visto il contesto nel quale ci si pone, le problematiche identificate hanno portato, come citato all'interno dell'analisi dei requisiti, alla definizioni di una serie di concetti per le varie modalità di esecuzione delle azioni. Occorre identificare una modalità che ci permetta di astrarre dallo specifico problema in gioco (ovvero quello dei robot) e che ci consenta di definire una soluzione generale alla problematica, sfruttano il robot come approccio, definendo i concetti validi anche per future fasi evolutive del progetto. I requisiti ci portano a riconoscere una serie di problematiche delle quali ci andremo ad occupare: definizioni di azioni sincrone/asicrone ed azioni interrompibili.\\
Ponendoci nel contesto di esempio, il robot deve essere sensibile ad alcuni cambiamenti che potranno avvenire nell'ambiente circostante nel quale è situato. Occorre, quindi, definire la gestione di questi cambiamenti in modo che durante l'esecuzione delle azioni previste, nel caso di rilevamento di un cambiamento, il robot possa reagire di conseguenza. In particolare si vuole fare in modo che l'azione intrapresa dal robot si blocchi e si possano eseguire azioni alternative, al termine di queste sarà necessario valutare se continuare con l'esecuzione precedente che include le azioni già pianificate.\\
Così facendo occorre definire, dato un robot, tutti i cambiamenti ai quali dev'essere in grado di reagire, descrivendo i comportamenti da avere in ogni situazione e le modalità di controllo che permettano di fare una valutazione sullo stato di avanzamento dell'azione corrente intrapresa dal robot.
Inoltre è necessario riconoscere quando un'azione è giunta al termine in modo da controllare lo stato dell'azione ed eventualmente proseguire con la successiva.\\
La base di partenza per noi è l'astrazione di classe BaseRobot il quale tramite apposito metodo ha la possibilità di eseguire azioni tramite l?uso di appositi attuatori, all?interno del mondo reale. Legata alla problematica identificata, sorge inoltre il problema di specificare la tipologia di azione da utilizzare all'interno al contesto in esame dato che questa, avrà effetti sul controllo del robot stesso e sul comportamento dell'architettura logica creata a valle.\\
Si vogliono fissare le definizioni relative alle possibili azioni utilizzate all'interno del contesto del problema appena definito:
\begin{itemize}
\item \textbf{Azione sincrona}: si considera un'esecuzione sincrona, di una azione, quando questa viene concretizzata e occorre attendere la terminazione della stessa per poter restituire il controllo al chiamante.

\item \textbf{Azione asincrona}: si definisce un'esecuzione asincrona quando una determinata azione può essere eseguita senza che il chiamante debba attendere la fine dell'esecuzione dato che il controllo viene immediatamente restituito al chiamante.
\end{itemize}

Rispetto alla fase precedente si deve considerare un sistema non più concentrato ma distribuito, infatti l'utilizzo della console remota rende necessaria la definizione della comunicazione tra quest'ultima e il robot. Dev'essere definito un comando di "halt" che la console sia in grado di inviare al robot e quest'ultimo dovrà essere in grado di interpretarlo.

%===========================================================================
\subsection{Logic architecture}
Ci poniamo nell'ottica di ottenere un modello del sistema funzionante e globalmente accettato da tutte le parti in gioco, identificando i macro sottosistemi senza specificare nulla più di quanto già detto precedentemente. Il tutto rimanendo indipendenti dalla specifica tecnologia che si utilizzerà e demandando queste decisioni solo durante la fase di progetto.

\subsubsection{Struttura}
Da quanto detto, si identificano principalmente tre sottosistemi:
\begin{itemize}
	\item altri eventuali sistemi in grado di ricevere segnali presenti nell'ambiente (world);
	\item console remota;
	\item robot system.
\end{itemize}

Mentre con il primo si identifica l'\textbf{ecosistema} in cui opera il robot ed altri eventuali sistemi esterni presenti, la console remota riveste il ruolo di emittente di determinati segnali in grado di essere captati dal robot system specifico o da una serie di robot interessati ad una specifica tipologia. Quest'ultimo risulta essere strutturato su una serie di livelli che vanno ad arricchire le caratteristiche del robot stesso, raggiungendo così un livello di astrazione più consono al progetto richiesto.
\\
\newline
\\
\begin{tabular}{ | c | }
	\hline
	Struttura \\
	\hline	
	\includegraphics[scale = 0.4]{img/struttura.jpg}\\
	\hline
\end{tabular}
\\
\newline
\\
All'interno del diagramma si è voluto anche rappresentare il \textbf{"mondo"}, situando così il robot ed identificando il contesto di esecuzione del piano stesso.
Un'ulteriore sottosistema identificato, come già detto, è la \textbf{console remota} che, ai fini dettati dal testing del sistema, verrà posta all'interno del sistema RemoteConsole e sarà quindi in grado di inviare il messaggio di "halt".
Si lascia inoltre spazio, in questa rappresentazione, ad ulteriori sistemi presenti nel "mondo" ed in grado di interagire con i principali sistemi proposti nell'architettura logica, in modo da focalizzarsi solo sulla definizione dei vincoli di interazione e senza complicare ulteriormente la struttura e il comportamento del sistema nel suo complesso.

\subsubsection{Interazione}
Ricordando la base di partenza ovvero il contesto distribuito del robot, occorre introdurre il concetto di rete come mezzo di comunicazione per l'invio di comandi. Come si può vedere dal diagramma sottostante il RobotSystem interagisce con il sottosistema RemoteConsole e nel caso in cui quest'ultimo invii un comando di "halt", il RobotSystem lo gestirà terminando l'azione che stava eseguendo. Qualora dal sottosistema RemoteConsole non arrivasse un comando di "halt", il RobotSystem inizierà la sua azione e la porterà a compimento.
\\
\newline
\\
\begin{tabular}{ | c | }
	\hline
	Interazione \\
	\hline	
	\includegraphics[scale = 0.4]{img/Interazione.jpg}\\
	\hline
\end{tabular}

\subsubsection{Comportamento}
Viste le premesse fatte negli capitoli precedenti, e utilizzando la base di conoscenza a nostra disposizione proveniente da specifici corsi di studi, la problematica identificata ci spinge a modellare il comportamento del robot come un automa a stati finiti.
Un primo prototipo potrebbe essere il seguente in cui viene rappresentata l?esecuzione di un azione che, nel caso in cui non avvengo la ricezione del comando ?halt?, termina.
\\
\newline
\\
\begin{tabular}{ |c| }
	\hline
	Comportamento \\
	\hline	
	\includegraphics[scale = 0.6]{img/Epsilon.jpg}\\
	\hline
\end{tabular}
\\
\newline
\\
Per modellare il "comportamento di default" del robot, quindi l'esecuzione dell'azione senza l'interruzione provieniente dalla console remota, andrebbe introdotto il concetto di "epsilon mossa". Per epsilon mossa di intende una transizione che avviene senza avere nulla in ingresso, che è proprietà specifica degli automi a stati finiti. Questa soluzione non è modellabile all'interno del dominio applicativo fin qui definito, infatti supponendo di utilizzare un azione asincrona, questa terminerà immediatamente senza che venga effettivamente attuata nel mondo. Nasce quindi la necessità di introdurre un livello di astrazione superiore che permetta di esprimere in modo corretto il comportamento del robot e che consenta di effettuare la transizione di stato solo al momento opportuno, ovvero al termine dell?esecuzione dell?azione.


% ----codice dsl---

\subsection{Abstraction gap}
Avendo appena definito i concetti principali nei capitoli precedenti, ci si rende conto che la base di partenza considerata, ovvero il linguaggio OO Java, non permette di esprimere ad un sufficiente livello di astrazione le tematiche sopra citate e il dislivello dal punto di vista tecnologico sarebbe troppo ampio da essere colmato. Si procede quindi alla definizione di una serie di livelli di astrazione che permettano di arrivare gradualmente a definire le modalità di approccio al problema.


%Avendo a che fare con un argomento caratterizzato da una impronta tecnologica molto spinta che porta ad avere concetti innovativi, ci si rende conto che le astrazioni di base proposte con la programmazione object oriented fino ad ora utilizzata, non sono più in grado di soddisfare le problematiche fino a qui identificate. I concetti fino ad ora identificati portano un abstraction gap consistente in riferimento alla nostra ipotesi di base. Per riuscire a superare il divario di astrazione in modo "modulare" si fa riferimento ad una serie di frameworks (personalizzati) come \textbf{QActors} e \textbf{QStream} (per quando riguarda la gestione di messaggi), \textbf{QEvents} (per la gestione dell'event driven programming). 
%Per sfruttare appieno l'uso dei framework proposti, si usa il DSL aziendale che permette di esprimere in maniera formale e intuibile da tutti il funzionamento del sistema e di ottenere in maniera automatica il codice eseguibile relativo.
%L'uso del DSL aziendale non viene scelto solo per la semplicità d'uso ma per la caratteristica di permettere la generazione di codice del tutto automatica e quindi l'abbattimento dei costi di produzione del software.

%Nella figura successiva viene visualizzata la struttura layer identificata a partire dall'object oriented programming, deciso come base di partenza, a cui si appoggiano i layer precedentemente identificati, i quali potranno essere tutti sfruttati dall'ultimo ovvero highRobot.spec per colmare l'abstraction gap identificato.
%\\
%\newline
%\\
%\begin{tabular}{ |p{12.0cm}| }
%	\hline
%	Comportamento \\
%	\hline	
%	\includegraphics[scale = 0.6]{img/layer.jpg}\\
%	\hline
%\end{tabular}
%\\
%\newline
%\\
\subsection{Risk analysis}
%I rischi legati al progetto sono da imputare alla scelta fatta di utilizzare il DSL aziendale come fonte per colmare l'abstraction gap precedentemente identificato, infatti questa scelta definisce una serie di vantaggi e svantaggi.

%\subsubsection{SVANTAGGI}

%\begin{itemize}
%	\item Per poter comprendere appieno la semantica del linguaggio occorre investire una certa quantità di tempo nell'analisi del codice generato. Questo è dovuto al fatto che non risulta essere ancora presente un modello opportuno dei comandi, e delle operazioni computabili attraverso il DSL. Manca inoltre ancora una documentazione precisa per poter permettere anche ad utenti meno esperti di formarsi in relazione all'utilizzo del DSL. Per questo motivo parte del tempo speso anche dal team è stato per cercare di comprendere le scelte che hanno portato il system designer a risolvere un determinato problema in un modo piuttosto che in un altro. L'unico modo per poter capire questo è stata un'attenta analisi del codice generato. Per questo, vi è ancora un certo grado di ambiguità per alcuni dei concetti inseriti all'interno del DSL, portando l'utente che lo sfrutta a lavorare con uno strumento di modellazione che esprime concetti non completamente chiari e condivisibili da tutti;
%	\item Un altro elemento negativo identificato, proviene parzialmente dalle caratteristiche espresse nella parte precedente ed è inoltre legato alla struttura intrinseca del DSL stesso, ovvero la sua struttura layered. Infatti come detto prima, per poter essere padroni nell'utilizzo del linguaggio occorre una lunga fase di testing sperimentale che porta ad avere una curva di apprendimento più lunga non avendo una documentazione sulla quale appoggiarsi, nè in fase di utilizzo per la generazione di codice nè nella successiva fase di debug. Inoltre se si identifica un problema all'interno di uno dei layer che costituiscono il DSL, difficilmente qualcuno di diverso da chi ha scritto il codice riuscirà a risolvere la problematica identificata.
%	\item La struttura del DSL così costituita, porta a fare si che nel momento in cui si voglia introdurre un upgrade della stessa per modificare un comportamento, o di una modifica della semantica, presente all'interno di uno dei layer definiti, le ripercussioni che si avranno saranno visibili solo in fase di messa in esecuzione del sistema e non in fase di definizione della nuova feature. La modifica inserita inoltre, data la mancanza di un modello formale, rischia inoltre di riperquotersi in maniera impredicibile su ciò che è già stato creato in precedenza.
%\end{itemize}

%Dalle problematiche identificate si nota come risulti fondamentale definire almeno un modello che chiunque possa sfruttare per capire i concetti esprimibili con il DSL e gli permetta, anche senza una conoscenza approfondita delle caratteristiche di ogni layer costituente, di sfruttare appieno le caratteristiche investendo così più tempo nella risoluzione avendo mitigato in parte la curva di apprendimento di uso del software avendo a disposizione un aiuto in più.
%Inoltre risulterebbe utile definire una serie di invarianti di sistema, magari concordando pareri di un system designer (chi cioè crea ed estende il DSL) con un project designer (chi sfrutta il DSL) per definire una serie di concetti che anche in un nuovo update di versione non debbano mutare.

%\subsubsection{VANTAGGI}
%Si vogliono comunque specificare i numerosi aspetti positivi identificati nell'uso del DSL, infatti anche se sono stati precedentemente presentati gli svantaggi, una volta pesati questi con i punti di forza sulle quali si basa il DSL si capisce il perchè comunque è stato scelto questo approccio. Infatti considerando di avere a disposizione un modello chiaro e condiviso a livello aziendale, il vantaggio che si ottiene dal punto di vista temporale durante la fase di generazione del codice risulta essere sostanziale e permette inoltre la produzione di artefatti già dalle fase di analisi i quali svolgono il duplice scopo di modello di sistema utile alla comprensione dello stesso e parte fondante per la generazione di codice.
%Altro aspetto fondamentale, almeno nell'ambito dell'IoT nel quale è inserito il nostro progetto è la forte riusabilità del codice garantita dall'uso del DSL, questo requisito, anche se identificato come non funzionale, risulta essere importante anche ai fini del corso e difficilmente con altre modalità operative risulta essere ottenibile. 

%===========================================================================
\section{Work plan}
\labelsec{wplan}
	
%===========================================================================

%===========================================================================
\section{Project}
\labelsec{Project}
%===========================================================================

\subsection{Structure}
\subsection{Interaction}
\subsection{Behavior}

%===========================================================================
\section{Implementation}
\labelsec{Implementation}
%===========================================================================

%===========================================================================
\section{Testing}
\labelsec{testing}
%===========================================================================

%===========================================================================
\section{Deployment}
\labelsec{Deployment}
%===========================================================================

%===========================================================================
\section{Maintenance}
\labelsec{Maintenance}
%===========================================================================
\newpage

%===========================================================================
\section{Information about the author}
\labelsec{Author}
%===========================================================================

\vskip.5cm
%%% \begin{figure}
\begin{tabular}{ | c | | c || c | }
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  \hline
  Alessia Papini & Beatrice Mezzapesa & Lorenzo Pontellini \\
  \hline
  \hline
  
  \includegraphics[scale = 0.6]{img/ale.jpg} &  \includegraphics[scale = 0.6]{img/bea.jpg} & \includegraphics[scale = 0.6]{img/io.jpg} \\
  
  \hline
\end{tabular}


%%% \begin{itemize}
%%% \item Titolo di studio:\\ \\
%%% \item Interessi particolari:\\ \\
%%% \item Ha sostenuto fino ad oggi il seguente numero di esami:\\ \\
%%% \item Deve ancora sostenere i seguenti esami del I anno:\\ \\
%%% \item Prevede di svolgere un tirocinio presso:\\ \\
%%% \item Prevede di laurearsi nella sessione:\\ \\
%%% \item Intende proseguire gli studi per conseguire: \\  \\  \\
%%%   	presso la sede universitaria di: \\ \\
%%% \item Intende entrare subito nel mondo del lavoro presso : \\ \\
%%% \end{itemize}

 
\appendix


\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}